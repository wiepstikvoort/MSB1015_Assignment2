---
title: "Assignment_2_MSB1015"
author: "Wiep Stikvoort"
date: "October 12, 2019"
output: html_notebook
---
rcdk vignet, multilinear regression model for boiling points

get the smiles and boiling points with the wikidataqueryserviceR package
parse them with the rrdkit or the rcdk

First, we need to load the packages needed for the query and the computations for the regression model. 
```{r setup, installing packages, echo=FALSE}
install.packages('rJava')
library(rJava)
install.packages('rcdk')
library(rcdk)
install.packages('pls')
library(pls)

install.packages('WikidataQueryServiceR')
library(WikidataQueryServiceR)
install.packages('caTools')
library('caTools')
library('ggplot2')

```


This is the correct query:
``` {r}
query <- query_wikidata('SELECT DISTINCT ?comp ?compLabel ?bp ?bpUnit ?bpUnitLabel ?CC
WHERE {   
?comp wdt:P31/wdt:P279* wd:Q41581 ;       
wdt:P233 ?CC  ;
p:P2102 [ ps:P2102 ?bp ;  
psv:P2102/wikibase:quantityUnit  ?bpUnit         ] .  
SERVICE wikibase:label { bd:serviceParam wikibase:language "[AUTO_LANGUAGE],en". } }')
```

There are still some compounds with their boiling points in degree celcius or fahrenheit. These need to be changed to kelvin:

```{r}
fahrenheit_kelvin <- function(fahrenheit) {
  kelvin <- (fahrenheit + 459.67) * (5/9)
  return(kelvin)
}
celsius_kelvin <- function(celcius) {
  kelvin <- celcius + 293.15
  return(kelvin)
}

for (i in 1:length(query$bpUnitLabel)) {
  if(query$bpUnitLabel[i] == 'degree Celsius'){
      query$bp[i] <- celsius_kelvin(query$bp[i])
      query$bpUnitLabel[i] <- 'kelvin'
      }
  else if (query$bpUnitLabel[i] == 'degree Fahrenheit'){
     query$bp[i] <- fahrenheit_kelvin(query$bp[i])
     query$bpUnitLabel[i] <- 'kelvin'
  }
}

# To check whether there are no more strange values, such as divergent units, in the dataset, a plot is created. This plot should show that all points are somewhat in the same range of values. 
plot.default(query$bp)

```


The data is split into test and training set. 80% of the data is used for the training set, the other 20% will then logically be part of the test set. 
```{r}
data <- sort(sample(nrow(query), nrow(query)*.8))
training_set<-query[data,]

#creating test data set by not selecting the output row values
test_set<-query[-data,]
```


Descriptors 
```{r}
# the parse.smiles function creates IAtomContainer objects out of SMILES. Kekulise = TRUE disables the function to parse incorrect SMILES. So only correct SMILES are parsed. 
parsed_smiles <- parse.smiles(training_set$CC, kekulise=TRUE)

descNames <- c(
'org.openscience.cdk.qsar.descriptors.molecular.FragmentComplexityDescriptor',
'org.openscience.cdk.qsar.descriptors.molecular.APolDescriptor',
'org.openscience.cdk.qsar.descriptors.molecular.WienerNumbersDescriptor',
'org.openscience.cdk.qsar.descriptors.molecular.MDEDescriptor',
'org.openscience.cdk.qsar.descriptors.molecular.AtomCountDescriptor')

descs <- eval.desc(parsed_smiles, descNames)
training <- cbind(training_set, descs)

```

``` {r}


model <- plsr(bp ~ WPATH  + fragC + apol + WPATH + WPOL + MDEC.12 + nAtom, data = training, validation = "LOO") 

plot(model, asp = 1, line = TRUE)


parsed_smiles_test <- parse.smiles(test_set$CC, kekulise = TRUE)
descs_test <- eval.desc(parsed_smiles_test, descNames)

plot(RMSEP(model), legendpos = "topright")

test <- cbind(test_set, descs_test)
error <- RMSEP(model, newdata = test)
plot(error, legendpos = "topright")

predict <- predict(model, ncomp = 3, newdata = test) # 
plot(predict, test_set$bp)
corcoef <- cor(predict, test_set$bp)
print(error)
```

``` {r}
# the query for the amino acids is not much different from the query for the alcanes, except for the fact that mass is now requested instead of boiling points

query_amino_acids <- query_wikidata('SELECT DISTINCT ?comp ?compLabel ?mass ?massUnit ?massUnitLabel ?CC
WHERE {   
?comp wdt:P31/wdt:P279* wd:Q8066 ;       
wdt:P233 ?CC  ;
p:P2067 [ ps:P2067 ?mass ;  
psv:P2067/wikibase:quantityUnit  ?massUnit         ] .  
SERVICE wikibase:label { bd:serviceParam wikibase:language "[AUTO_LANGUAGE],en". } }')
```
All compound masses were expressed in the atomic mass unit, so no need for conversions. 

```{r}
data_aa <- sort(sample(nrow(query_amino_acids), nrow(query_amino_acids)*.8))
training_set_aa<-query_amino_acids[data_aa,]

#creating test data set by not selecting the output row values
test_set_aa<-query_amino_acids[-data_aa,]
```

Descriptors 
```{r}
parsed_smiles_aa <- parse.smiles(training_set_aa$CC, kekulise=TRUE) # changes it into a format IAtomContainer

descNames <- c(
'org.openscience.cdk.qsar.descriptors.molecular.FragmentComplexityDescriptor',
'org.openscience.cdk.qsar.descriptors.molecular.APolDescriptor',
'org.openscience.cdk.qsar.descriptors.molecular.WienerNumbersDescriptor',
'org.openscience.cdk.qsar.descriptors.molecular.MDEDescriptor',
'org.openscience.cdk.qsar.descriptors.molecular.AtomCountDescriptor')

descs_aa <- eval.desc(parsed_smiles_aa, descNames)
training_aa <- cbind(training_set_aa, descs_aa)

```

``` {r}

model_aa <- plsr(mass ~ WPATH + fragC + apol + WPATH + WPOL + MDEC.12 + nAtom, data = training_aa, validation = "LOO") 

plot(model_aa, asp = 1, line = TRUE)


parsed_smiles_test_aa <- parse.smiles(test_set_aa$CC, kekulise = TRUE)
descs_test_aa <- eval.desc(parsed_smiles_test_aa, descNames)

plot(RMSEP(model_aa), legendpos = "topright")

test_aa <- cbind(test_set_aa, descs_test_aa)
error_aa <- RMSEP(model_aa, newdata = test_aa)
plot(error_aa, legendpos = "topright")

predict_aa <- predict(model_aa, ncomp = 3, newdata = test_aa) # 
plot(predict_aa, test_set_aa$bp)
corcoef_aa <- cor(predict_aa, test_set_aa$mass)
print(error_aa)
```