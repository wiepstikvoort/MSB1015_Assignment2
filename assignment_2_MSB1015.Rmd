---
title: "Assignment_2_MSB1015"
author: "Wiep Stikvoort"
date: "September 23, 2019"
output: html_notebook
---
rrdkit? <- r package
rcdk vignet, multilinear regression model for boiling points
github repository set up for assignment 2

get the smiles and boiling points with the wikidataqueryserviceR package
parse them with the rrdkit or the rcdk

First, we need to load the packages needed for the query and the computations for the regression model. 
```{r setup, installing packages, echo=FALSE}
install.packages('SPARQL')
library(SPARQL)
install.packages('rJava')
library(rJava)
install.packages('rcdk')
library(rcdk)
install.packages('pls')
library(pls)
install.packages('XML')
library(XML)
library(RCurl)
install.packages('rjson')
library(rjson)
library(httr)
install.packages('WDQS')
library(WDQS)
install.packages('WikidataQueryServiceR')
library(WikidataQueryServiceR)
install.packages('caTools')
library('caTools')

```


new tryout of query
```{r library, echo=FALSE}
endp <- "http://query.wikidata.org/"
# prefix <- c("wd","<http://www.wikidata.org/entity/>",
#             "wdt","<http://www.wikidata.org/prop/direct/>")
 
# create query statement
q <- 'PREFIX wd: <http://www.wikidata.org/entity/>
PREFIX wdt: <http://www.wikidata.org/prop/direct/>

SELECT ?item ?itemLabel WHERE {
?item wdt:P31 wd:Q2934 .
SERVICE wikibase:label { bd:serviceParam wikibase:language "[AUTO_LANGUAGE],en". }
}'
 
# Step 2 - Use SPARQL package to submit query and save results to a data frame
# options <- "output=xml" 
qd <- SPARQL(endp,q)
df <- qd$results

# 
# SELECT ?alkaneLabel ?alkane WHERE {
#             VALUES ?alkane {wd:Q134192 wd:Q150429 wd:Q150440} .
#                     ?alkane wdt:P31/wdt:P279* wd:Q41581 .
```


Trying the new R package for retrieving data

```{r}
query <- query_wikidata('
      SELECT DISTINCT ?alkane ?alkaneLabel ?boilingpoint ?unit ?smiles WHERE {
          ?alkane (wdt:P31|wdt:P279) wd:Q11173;
            rdfs:label ?alkaneLabel;
            wdt:P2102 ?boilingpoint;
            wdt:P233 ?smiles;
  OPTIONAL {
   # unit 
    ?alkane p:P2102/psv:P2102 [  wikibase:quantityUnit       ?unit ].}
          FILTER(STRENDS(?alkaneLabel, "ane"))
          FILTER((LANG(?alkaneLabel)) = "en")
        }')

```
New query that only contains linear alcanes
```{r}
query_new <- query_wikidata('
SELECT ?anes ?anesLabel ?CC ?bp
WHERE {
?anes wdt:P31/wdt:P279* wd:Q41581 .
?anes wdt:P233 ?CC .
?anes wdt:P2102 ?bp .
SERVICE wikibase:label { bd:serviceParam wikibase:language 'en' }
})
```


``` {r}
query_new2 <- query_wikidata('SELECT ?comp ?compLabel ?bp ?bpUnit ?bpUnitLabel ?CC
WHERE {   
?comp wdt:P31/wdt:P279* wd:Q41581 ;       wdt:P233 ?CC  ;
p:P2102 [ ps:P2102 ?bp ;  
psv:P2102/wikibase:quantityUnit  ?bpUnit         ] .  
SERVICE wikibase:label { bd:serviceParam wikibase:language "[AUTO_LANGUAGE],en". } }')
```

Splitting the data into testset and trainingset
```{r}
sample = sample.split(query_new2, SplitRatio = 3/4)
training_set = subset(query_new2, sample == TRUE)
test_set = subset(query_new2, sample == FALSE)
```

descriptors 
```{r}
parsed_smiles <- parse.smiles(training_set$CC, kekulise=TRUE) # changes it into a format IAtomContainer

descNames <- c(
'org.openscience.cdk.qsar.descriptors.molecular.FragmentComplexityDescriptor',
'org.openscience.cdk.qsar.descriptors.molecular.APolDescriptor',
'org.openscience.cdk.qsar.descriptors.molecular.WienerNumbersDescriptor'
)

descs <- eval.desc(parsed_smiles, descNames)

```

``` {r}

model <- plsr(bp ~ ., data = training_set, validation = "CV") # creates a model for each component
# intercept is the null moplot(model)

# voorspellen op basis van je testdata
predict <- predict(model, test_set) # 
plot(predict, test_set$bp)
```

